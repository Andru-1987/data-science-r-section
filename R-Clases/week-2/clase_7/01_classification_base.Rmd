---
title: "Modelos de Clasificacion"
author: "Anderson Ocaña"
date: "`r Sys.Date()`"
output: 
  # html_document:
  #   toc: true
  #   toc_float: true
  #   theme: united
  #   highlight: tango
  #   code_folding: show
  pdf_document:
    toc: true
    number_sections: true
    highlight: tango
fontsize: 10pt
geometry: margin=1in
---


## Clasificacion -> Transformando un modelo presuntamente de Regression a uno de Clasificacion MultiClass

### 1. Crear categorías a partir de `charges`

```{R install, include=FALSE}
packages <- c("tidymodels", "ggplot2", "dplyr","glmnet", "ranger", "xgboost","GGally","corrplot","kknn","shiny")
install.packages(setdiff(packages, rownames(installed.packages())))
```

```{R import-libraries}
library(tidymodels)
library(GGally)
library(corrplot)
library(kknn)
library(yardstick)
```

```{R load-dataset}
url_local <- "R-Clases/week-2/clase_7/data_storage/insurance.csv"
df <- read.csv(url_local)

glimpse(df)
summary(df)

```
Podemos usar `cut()` para dividir `charges` en 4 categorías, por ejemplo: *bajo*, *medio*, *alto*, *muy alto*.


```{R}
df <- df %>%
  mutate(charges_cat = cut(charges,
                           breaks = quantile(charges, probs = seq(0, 1, 0.25)),
                           include.lowest = TRUE,
                           labels = c("bajo", "medio", "alto", "muy alto")))
head(df,5)
```

### 2. EDA

```{R}
table(df$charges_cat)
```

```{R eda-missing-values}

null_counts <- df %>%
  summarise_all(~ sum(is.na(.))) %>%
  pivot_longer(everything(), names_to = "Variable", values_to = "Null_Count")


p1 <- ggplot(
  data=null_counts,
  aes(x = reorder(Variable, -Null_Count), y = Null_Count)) +

  geom_bar(stat = "identity", fill = "steelblue", alpha = 0.7) +
  geom_text(aes(label = Null_Count), vjust = -0.3, size = 3.5) +
  labs(
    title = "Cantidad de Valores Nulos por Variable",
    subtitle = "Dataset: Insurance",
    x = "Variables",
    y = "Número de Valores Nulos"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 12)
  )

p1
```

```{R eda-histogramas}
library(ggplot2)
library(patchwork) # Para organizar múltiples gráficos

# Histogramas con densidad
p1 <- ggplot(df, aes(x = age)) + 
  geom_histogram(aes(y = after_stat(density)), bins = 30, fill = "skyblue", color = "black") +

  geom_density(color = "red") +
  ggtitle("Distribución de Edad")

p2 <- ggplot(df, aes(x = bmi)) + 
  geom_histogram(aes(y = after_stat(density)), bins = 30, fill = "lightgreen", color = "black") +
  geom_density(color = "red") +
  ggtitle("Distribución de BMI")

p3 <- ggplot(df, aes(x = charges)) + 
  geom_histogram(aes(y = after_stat(density)), bins = 30, fill = "salmon", color = "black") +
  geom_density(color = "red") +
  ggtitle("Distribución de Cargos Médicos")

(p1 + p2) / p3  # Organización con patchwork
```


```{R eda-charges}
# Boxplot por fumador (smoker)
p1 <- ggplot(df, aes(x = smoker, y = charges, fill = smoker)) +
  geom_boxplot() +
  ggtitle("Cargos Médicos por Fumador") +
  theme_minimal()

# Boxplot por región
p2 <- ggplot(df, aes(x = region, y = charges, fill = region)) +
  geom_boxplot() +
  ggtitle("Cargos Médicos por Región") +
  theme_minimal()


p1 / p2
```


```{R eda-distribucion-categoricas}
# Proporción de fumadores
p1 <- ggplot(df, aes(x = smoker, fill = smoker)) +
  geom_bar() +
  ggtitle("Distribución de Fumadores") +
  theme_minimal()

# Proporción por región y sexo
p2 <- ggplot(df, aes(x = region, fill = sex)) +
  geom_bar(position = "dodge") +
  ggtitle("Distribución por Región y Sexo") +
  theme_minimal()

p1 / p2
```


```{R eda-corr-variables-numericas}
library(GGally)
library(dplyr)

# Selecciona solo columnas numéricas automáticamente
ggcorr(df %>% select_if(is.numeric), 
       label = TRUE, 
       label_size = 3,
       hjust = 0.8)
```

```{R correlacion-num-cat}
library(dplyr)
library(GGally)

df_coded <- df %>%
  mutate(
    smoker_num = as.numeric(smoker == "yes"),  # 1 para "yes", 0 para "no"
    sex_num = as.numeric(sex == "male"),       # 1 para "male", 0 para "female"
    region_num = as.numeric(factor(region))    # Asigna números a cada región
  )

# Nueva matriz de correlación (incluye categóricas transformadas)
cor_matrix_full <- cor(df_coded %>% select_if(is.numeric), method = "spearman")

cor_matrix_full

# Gráfico combinado con ggpairs (incluye correlaciones)
ggpairs(df_coded %>% select(age, bmi, charges, smoker_num, sex_num),
        upper = list(continuous = wrap("cor", method = "kendall")))
```


### 3. Preparar datos para clasificación

```{R}
set.seed(42)
split <- initial_split(df, prop = 0.8, strata = charges_cat)  # acá ya estratificamos por categoría
train_data <- training(split)
test_data <- testing(split)
```

### 4. Crear receta (preprocesamiento)

```{R}
base_recipe <- recipe(charges_cat ~ age + sex + bmi + children + smoker + region, data = train_data) %>%
  # limpieza básica
  step_zv(all_predictors()) %>%                # remover variables con varianza 0
  step_nzv(all_predictors()) %>%               # near-zero variance
  step_impute_median(all_numeric_predictors()) %>%
  step_other(all_nominal_predictors(), threshold = 0.01) %>% # agrupar levels raros
  step_dummy(all_nominal_predictors()) %>%
  step_normalize(all_numeric_predictors())
```

### 5. Definir modelo de clasificación

```{R modelos-basicos-clasificacion-parnish}
tree_spec <- decision_tree(cost_complexity = 0.01, tree_depth = 5, min_n = 5) %>%
  set_engine("rpart") %>%
  set_mode("classification")

multinom_spec <- multinom_reg(penalty = 0.1, mixture = 0.5) %>%
  set_engine("glmnet") %>%
  set_mode("classification")

rf_spec <- rand_forest(mtry = 3, trees = 500, min_n = 5) %>%
  set_engine("ranger") %>%
  set_mode("classification")

xgb_spec <- boost_tree(trees = 1000, tree_depth = 6, learn_rate = 0.1, loss_reduction = 0, sample_size = 1) %>%
  set_engine("xgboost") %>%
  set_mode("classification")

knn_spec <- nearest_neighbor(neighbors = 5, weight_func = "rectangular") %>%
  set_engine("kknn") %>%
  set_mode("classification")
  
# Workflows ---------------------------------------------------------------
workflows <- list(
  wf_tree = workflow() %>% add_model(tree_spec) %>% add_recipe(base_recipe),
  wf_multinom = workflow() %>% add_model(multinom_spec) %>% add_recipe(base_recipe),
  wf_rf =workflow() %>% add_model(rf_spec) %>% add_recipe(base_recipe),
  wf_xgb  =workflow() %>% add_model(xgb_spec) %>% add_recipe(base_recipe),
  wf_knn  =workflow() %>% add_model(knn_spec) %>% add_recipe(base_recipe)
  )


workflows
```
### 7. Evaluar el modelo

```{R evaluacion-modelo}
library(tidymodels)
library(yardstick)
library(rlang)

set.seed(42)
evaluate_workflow <- function(wf, train_data, test_data, target_col) {

  fit_model <- fit(wf, data = train_data)
  
  pred_prob <- predict(fit_model, test_data, type = "prob")
  pred_class <- predict(fit_model, test_data, type = "class")
  
  pred <- bind_cols(pred_prob, pred_class) %>%
    bind_cols(test_data %>% select(all_of(target_col))) %>%
    rename(.pred_class = 1 + ncol(pred_prob))
  
  metrics_set <- metric_set(accuracy, f_meas, precision, recall)
  
  results <- metrics_set(pred, truth = !!sym(target_col), estimate = .pred_class)
  
  results_roc_auc <- roc_auc(
    pred,
    truth = !!sym(target_col),
    !!!syms(names(pred_prob)),
    estimator = "macro_weighted"
  )
  
  results <- bind_rows(results, results_roc_auc)
  
  return(results)
}



```

```{R eval}
library(rlang)
target_var <- "charges_cat"  # cambia por tu variable objetivo

results_multinom <- evaluate_workflow(workflows$wf_multinom, train_data, test_data, target_var)
results_rf <- evaluate_workflow(workflows$wf_rf, train_data, test_data, target_var)
results_xgb <- evaluate_workflow(workflows$wf_xgb, train_data, test_data, target_var)
results_knn <- evaluate_workflow(workflows$wf_knn, train_data, test_data, target_var)
results_tree <- evaluate_workflow(workflows$wf_tree, train_data, test_data, target_var)

resultados_metrics <- bind_rows(
  results_multinom %>% mutate(model = "multinom"),
  results_rf %>% mutate(model = "rf"),
  results_xgb %>% mutate(model = "xgb"),
  results_knn %>% mutate(model = "knn"),
  results_tree %>% mutate(model = "tree")
) %>%
  select(model, .metric, .estimate) %>%
  pivot_wider(names_from = .metric, values_from = .estimate) %>%
  arrange(desc(roc_auc)) 
  

resultados_metrics
```

## Uso de Shiny

```{R shiny}
library(rlang) # para syms

get_roc_data <- function(fit_model, test_data, target_col) {
  prob_df <- predict(fit_model, test_data, type = "prob")
  truth_vec <- test_data[[target_col]]
  
  # Verificamos que truth sea factor
  if (!is.factor(truth_vec)) {
    truth_vec <- factor(truth_vec)
  }
  
  # Extraemos nombres de columnas de probabilidad que empiezan con .pred_
  prob_cols <- grep("^\\.pred_", colnames(prob_df), value = TRUE)
  
  # Comprobamos que los niveles coinciden
  levels_prob <- sub("^\\.pred_", "", prob_cols)
  levels_truth <- levels(truth_vec)
  
  if (!all(levels_prob %in% levels_truth)) {
    stop("Los niveles de probabilidad no coinciden con los niveles de la variable objetivo")
  }
  
  df_roc <- tibble(truth = truth_vec)
  df_roc <- bind_cols(df_roc, prob_df[, prob_cols])
  
  # Ejecutamos roc_curve con selección dinámica de columnas
  roc_df <- yardstick::roc_curve(df_roc, truth = truth, !!!syms(prob_cols),estimator = "macro_weighted")
  
  return(roc_df)
}


```

```{R shiny-ui}
library(shiny)
library(tidymodels)
library(ggplot2)
library(dplyr)
library(purrr)



ui <- fluidPage(
  titlePanel("Curvas ROC - Comparación modelos"),
  sidebarLayout(
    sidebarPanel(
      selectInput("model_choice", "Selecciona el modelo:", 
                  choices = c("rf", "xgb", "knn", "tree", "multinom"),
                  selected = "rf")
    ),
    mainPanel(
      plotOutput("rocPlot", height = "600px")
    )
  )
)

server <- function(input, output, session) {
  
  fits <- reactive({
    list(
      rf = fit(workflows$wf_rf, data = train_data),
      xgb = fit(workflows$wf_xgb, data = train_data),
      knn = fit(workflows$wf_knn, data = train_data),
      tree = fit(workflows$wf_tree, data = train_data),
      multinom = fit(workflows$wf_multinom, data = train_data)
    )
  })
  output$rocPlot <- renderPlot({
  target_var <- "charges_cat"
  
  fits_list <- fits()
  req(input$model_choice)
  validate(
    need(input$model_choice %in% names(fits_list), "Modelo no encontrado")
  )
  
  # Obtener curva ROC sólo del modelo seleccionado:
  fit_model <- fits_list[[input$model_choice]]
  roc_df <- get_roc_data(fit_model, test_data, target_var) %>%
    mutate(model = input$model_choice)
  
  ggplot(roc_df, aes(x = 1 - specificity, y = sensitivity, color = model)) +
    geom_line(size = 1.2) +
    geom_abline(linetype = "dashed") +
    labs(title = paste("Curva ROC - Modelo:", input$model_choice),
         x = "Tasa de Falsos Positivos (1 - especificidad)",
         y = "Tasa de Verdaderos Positivos (sensibilidad)",
         color = "Modelo") +
    theme_minimal() +
    theme(text = element_text(size = 16))
})


shinyApp(ui, server,  options = list(port = 8080))
```